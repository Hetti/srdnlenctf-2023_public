# srdnlenctf 2023

## L337tery (0 solves)

The service is a lottery that performs 7 rounds. Our objective is to guess correctly all 196 draws of one round.

Before the extractions we can try 3 times the `L337tery` class that implements the lottery. We can chose the initial `state`, used by `NLFRS`, and the `security_params`: for this last one we can use the one used by the service. After our choices, we get the draws of one round with our parameters.

### Solution

> The following solution assumes that the reader is well versed in both LFSRs and lattices. If that's not the case a good starting point for the first is its [wikipedia page](https://en.wikipedia.org/wiki/Linear-feedback_shift_register) and some basic ctf challenges that can be found easily. Whereas for the latter [this amazing paper](https://eprint.iacr.org/2023/032.pdf) should be enough.

To predict the lottery draws one needs to recover the internal `state` of `NLFSR` and the `security_params` used by the server.

Analizing the `NLFSR` filter function $f$ one notices that is extremely vulnerable, because there exist a function $g$, called **annihilator**, of degree one such that

$$ f(\textbf{x}) g(\textbf{x}) = 0, \quad \forall \textbf{x} = (x_1, \dots, x_{\ell}) \in \mathbb{F}_2^{\ell}. $$

with $\ell$ the number of variables in $f$ and $g$. 

This means that

$$ f(\textbf{x}) = 1 \Longrightarrow g(\textbf{x}) = 0, \quad \forall \textbf{x} \in \mathbb{F}_2^{\ell} $$

and vice versa

$$ g(\textbf{x}) = 1 \Longrightarrow f(\textbf{x}) = 0, \quad \forall \textbf{x} \in \mathbb{F}_2^{\ell}. $$

We can use this property of $f$ and $g$ to compute some initial states that will expose the `security_params` of the service.

Each element $v_i, i = 1, \dots, n$ of `security_params` is generated by two random numbers $x_i, y_i \in \mathbb{Z}_p$ like so

$$ v_i = (x_i y_i^m, x_i^2 y_i^{m - 1}, \dots, x_i^{m - 1} y_i^2, x_i^m y_i) $$

with $n = 96$ and $m = 196$, whereas each draw $w_i$ of `L337tery` is computed like so

$$ w_i = z_j x_i y_i^m + z_{j + 1} x_i^2 y_i^{m - 1} + \dots + z_{j + m - 1} x_i^m y_i \pmod{p} $$

where $z_j, z_{j + 1}, \dots, z_{j + m - 1}$ are the outputs of the filter function $f$ applied at the $j^{th}, (j + 1)^{th}, \dots, (j + m - 1)^{th}$ states of the `NLFSR` respectively.

Therefore, all draws are computed using the same outputs of the `NLFSR`. So if we compute two initial states that generate these as first draws

$$ w_i = x_i^k y_i^{m - k},\ w^{\prime}_i = x_i^{k^{\prime}} y_i^{m - k^{\prime}}, \quad \forall i = 1, \dots, n $$

with $| k - k^{\prime} | = 1$, we will easily recover the `security_params` of the service.

> See `vulnerable_initial_states` and `recover_security_params` from [solve.py](./src/solve.py) for the actual implementation.

Now that we know how to recover the `security_params` we can focus on the recovery of the `NLFSR` internal state during the 7 rounds lottery.

After each round we'll know the $n$ `draws` of that round: $(w_1, w_2, \dots, w_n)$. Given that $n < m$, our system of equations can't recover the outputs of `NLFSR`, but since the size of the `NLFSR` outputs is so small we can recover them with BKZ: LLL will not be enough.

Let $s$ be one possible solution of our system of equations and $K$ the $(m - n) \times m$ kernel matrix of our system. We can put to zero the first $m - n$ elements of $s$ like so

$$ s^{\prime} = s - \sum_{i = 1}^{m - n} s_i K_i $$

because $K$ is of the form $(I_{m - n}, K^{\prime})$.

Let $L$ be the following lattice

$$ L = \begin{pmatrix} I_{m - n} & K^{\prime} \\\ 0_{n \times (m - n)} & p I_n \end{pmatrix}. $$

We can use Kannan's embedding to define a new lattice $L^{\prime}$:

$$ L^{\prime} = \begin{pmatrix} L & 0_m^T \\\ s^{\prime} & M \end{pmatrix} $$

where $M$ is the embedding factor. When $L^{\prime}$ is reduced with BKZ, we should find the `NLFSR` outputs as one of its rows.

> See `recover_coeffs` from [solve.py](./src/solve.py) for the actual implementation, where we use only a subset of $K^{\prime}$ columns because BKZ loops forever for the full $K^{\prime}$: this comes quite handy since BKZ is slow.

After some rounds of the lottery we can recover the `NLFSR` internal state using the recovered outputs and $f$ and $g$ properties. We can use this to predict the next draws and win the lottery.

> See `recover_nlfsr_state` from [solve.py](./src/solve.py) for the actual implementation.

Here's the full code from [solve.py](./src/solve.py):

```py
from sage.all import *
from sage.crypto.boolean_function import BooleanFunction
from server import NLFSR, L337tery
from pwn import process, context
import itertools


def vulnerable_initial_states() -> "list[tuple[int, int]]":
    f_indexes = sorted(set(itertools.chain.from_iterable(NLFSR.filter)))

    n = len(f_indexes)
    B = BooleanPolynomialRing(n, [f"x{i}" for i in range(n)])
    xs = B.gens()
    index_to_var = {i: x for i, x in zip(f_indexes, xs)}
    var_to_index = {x: i for x, i in zip(xs, f_indexes)}

    f = sum(prod(index_to_var[i] for i in mon) for mon in NLFSR.filter)
    assert BooleanFunction(f).algebraic_immunity() == 1
    g = BooleanFunction(f).annihilator(1)
    g_indexes = [var_to_index[x] for mon in g.monomials() for x in mon.variables()]

    F = GF(2)
    P = PolynomialRing(F, "x")
    x = P.gen()
    char_poly = x**256 + sum(x**i for i in NLFSR.taps)
    S = Matrix.companion(char_poly, "bottom")

    initial_states = []
    for i in range(L337tery.ncoeffs - 1):
        if len(initial_states) >= 2:
            break

        M = Matrix(F, [sum((S**j)[g_indexes].rows()) for j in range(i)] + 
                      [sum((S**j)[g_indexes].rows()) for j in range(i + 1, L337tery.ncoeffs)], sparse=False)
        K = M.right_kernel()

        for k in K.basis():
            initial_state = list(map(int, S**-1337 * k))
            nlfsr = NLFSR(initial_state)

            assert all(nlfsr.output() == 0 for _ in range(i))
            if nlfsr.output() != 1:
                continue
            assert all(nlfsr.output() == 0 for _ in range(i + 1, L337tery.ncoeffs))

            initial_states.append((i, initial_state))
            break
    
    return initial_states


def recover_security_params() -> "list[list[int]]":
    global io, initial_states
    assert len(initial_states) == 2
    
    leaks = []
    for i, initial_state in initial_states:
        io.sendlineafter(b"Are you ready to partecipate to the grand lottery? ", b"Nope")
        io.sendlineafter(b"Give me your initial state: ", ", ".join(map(str, initial_state)).encode())
        io.sendlineafter(b"Do you want to use your security parameters? ", b"Nope")

        leak = io.recvline_startswith(b"Behold, the randomness").decode().split(": ").pop()
        leaks.append((i, list(map(int, leak.split(",")))))
    
    p, ncoeffs = L337tery.p, L337tery.ncoeffs
    (j1, leak1), (j2, leak2) = leaks
    
    security_params = []
    for l1, l2 in zip(leak1, leak2):
        g = l1 * pow(l2, -1, p) % p
        security_param = ([l1 * pow(g, i, p) % p for i in reversed(range(j1))] + 
                          [l1 * pow(g, -i, p) % p for i in range(j1, ncoeffs)])
        security_params.append(list(map(int, security_param)))
    
    return security_params


def recover_coeffs(draws: "list[int]") -> "list[int]":
    global security_params

    p = L337tery.p
    F = GF(p)

    M = Matrix(F, security_params)
    rhs = vector(F, draws)

    s = M.solve_right(rhs)
    K = M.right_kernel_matrix()
    for i, k in enumerate(K.rows()):
        s -= s[i] * k

    n = 50  # chosen after some attempts
    L = Matrix.block(ZZ, [[K[:, :K.nrows()], K[:, K.nrows():K.nrows() + n]],
                          [Matrix.zero(n, K.nrows()), p * Matrix.identity(n)]])
    embedding = 1
    L = Matrix.block(ZZ, [[L, Matrix.zero(L.nrows(), 1)],
                          [Matrix([s[:K.nrows() + n]]), Matrix([[embedding]])]])

    L = L.BKZ()

    for row in L:
        if row[-1] < 0:
            row *= -1
        if row[-1] == embedding and all(x in {0, 1} for x in map(int, row[:-1])):
            s += row[:K.nrows()] * K
            assert all(x in {0, 1} for x in map(int, s))
            return list(map(int, s.list()))
    return None


def recover_nlfsr_state(outputs: "list[int]") -> "list[int]":
    f_indexes = sorted(set(itertools.chain.from_iterable(NLFSR.filter)))

    n = len(f_indexes)
    B = BooleanPolynomialRing(n, [f"x{i}" for i in range(n)])
    xs = B.gens()
    index_to_var = {i: x for i, x in zip(f_indexes, xs)}
    var_to_index = {x: i for x, i in zip(xs, f_indexes)}

    f = sum(prod(index_to_var[i] for i in mon) for mon in NLFSR.filter)
    assert BooleanFunction(f).algebraic_immunity() == 1
    g = BooleanFunction(f).annihilator(1)
    g_indexes = [var_to_index[x] for mon in g.monomials() for x in mon.variables()]

    F = GF(2)
    P = PolynomialRing(F, "x")
    x = P.gen()
    char_poly = x**256 + sum(x**i for i in NLFSR.taps)
    S = Matrix.companion(char_poly, "bottom")

    M = Matrix(F, [sum((S**j)[g_indexes].rows()) for j, y in enumerate(outputs) if y], sparse=False)
    rhs = vector(F, [0 + g.constant_coefficient()] * M.nrows())
    s = M.solve_right(rhs)
    K = M.right_kernel()
    assert len(K.basis()) == 0

    initial_state = list(map(int, S**-1337 * s))
    return initial_state


def win_grand_lottery(rounds=7) -> bool:
    global io, security_params
    
    io.sendlineafter(b"Are you ready to partecipate to the grand lottery? ", b"Yes")

    outputs = []
    for r in range(rounds - 1):
        io.sendlineafter(b">>> ", ", ".join(["0"] * L337tery.ndraws).encode())
        data = io.recvline().decode().split(": ").pop()
        draws = list(map(int, data.split(",")))
        coeffs = recover_coeffs(draws)
        if coeffs is None:
            return False
        outputs.extend(coeffs)

        if outputs.count(1) >= 256:
            initial_state = recover_nlfsr_state(outputs)
            l337tery = L337tery(initial_state, security_params)
            for _ in range(r):
                l337tery.draws()
            assert l337tery.draws() == draws
            break
    else:
        return False
    
    io.sendlineafter(b">>> ", ", ".join(map(str, l337tery.draws())).encode())
    data = io.recvline(keepends=False).decode()
    if "Impressive" in data:
        print(data.split("grand prize: ").pop())
        return True

    return False


context.log_level = "INFO"

initial_states = vulnerable_initial_states()

outcome = False
while not outcome:
    io = process(["sage", "server.py"])
    security_params = recover_security_params()
    outcome = win_grand_lottery()
    io.close()
```
